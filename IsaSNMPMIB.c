/*
 * Note: this file originally auto-generated by mib2c using
 *        $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include <time.h>
#include <sys/utsname.h>
#include "IsaSNMPMIB.h"


static char my_login[] = "xziska03";
char my_currentTime[100];
int my_editableInt = 69;
int my_editableInt2;
char my_nameOS[100];

/** Initializes the IsaSNMPMIB module */
void
init_IsaSNMPMIB(void)
{
    const oid IsaLOGIN_oid[] = { 1,3,6,1,3,22,1 };
    const oid IsaTIME_oid[] = { 1,3,6,1,3,22,2 };
    const oid IsaINT_oid[] = { 1,3,6,1,3,22,3 };
    const oid IsaOSINFO_oid[] = { 1,3,6,1,3,22,4 };

  DEBUGMSGTL(("IsaSNMPMIB", "Initializing\n"));

    netsnmp_register_scalar(
        netsnmp_create_handler_registration("IsaLOGIN", handle_IsaLOGIN,
                               IsaLOGIN_oid, OID_LENGTH(IsaLOGIN_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("IsaTIME", handle_IsaTIME,
                               IsaTIME_oid, OID_LENGTH(IsaTIME_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("IsaINT", handle_IsaINT,
                               IsaINT_oid, OID_LENGTH(IsaINT_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("IsaOSINFO", handle_IsaOSINFO,
                               IsaOSINFO_oid, OID_LENGTH(IsaOSINFO_oid),
                               HANDLER_CAN_RONLY
        ));
}

int
handle_IsaLOGIN(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
(u_char *) &my_login, strlen(my_login));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_IsaLOGIN\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_IsaTIME(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    time_t rawtime;
    time( &rawtime );
    struct tm *timeinfo = localtime( &rawtime );
 	char buf[100];
	//int stringLength = strlen(asctime(timeinfo));
    strftime(buf, 100, "%Y-%m-%dT%H:%M:%S", timeinfo);
	long hourOffset = timezone/3600;
	long minutesOffset = timezone%3600;
	if(hourOffset != 0){
		snprintf(my_currentTime, 100, "%s%c%02ld:%02ld", buf, (hourOffset > 0) ? '+' : '-', hourOffset, minutesOffset);
	} else {
		snprintf(my_currentTime, 100, "%sZ", buf);
	}


    switch(reqinfo->mode) {
        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
(u_char *) &my_currentTime, strlen(my_currentTime));
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_IsaTIME\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_IsaINT(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
&my_editableInt, sizeof(my_editableInt));
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            my_editableInt2 = my_editableInt;
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
            my_editableInt = *(requests->requestvb->val.integer);
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage
            if ( XXX: error? ) {
                try _really_really_ hard to never get to this point
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            }*/
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            my_editableInt = my_editableInt2;
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_IsaINT\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_IsaOSINFO(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
	struct utsname unameData;    
	uname(&unameData);
	//memset(my_nameOS, '\0', sizeof(unameData.sysname) + 1);
	snprintf(my_nameOS, 100, "The name of this operating system is %s!", unameData.sysname);

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
 (u_char *) &my_nameOS, strlen(my_nameOS));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_IsaOSINFO\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
